using System;
using System.Collections.Generic;
using System.Text;
using Platform.BackGround;
using GameBase.DataStructure;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.IO;
using GameBase.Helpers;

namespace GameBase.BackGround.SimpleTile
{
    /*
     * 一个简单的地面拼合。
     * 
     * 如果需要支持3个以上的贴图，简单地修改一下代码就可以。
     * 
     * */
    [Obsolete("请使用VergeTileGround类以达到更好效果")]
    public class SimpleTileGround : IBackGround
    {
        #region Variables

        Rectangle screenViewRect;

        int gridWidth;

        int gridHeight;

        int[] texIndexs;

        VertexBuffer vertexs;
        VertexDeclaration vertexDeclar;

        IndexBuffer indexs;

        Texture2D texIndexTex;

        Texture2D[] TexList;


        Vector2 mapSize;

        Effect simpleTileEffect;

        EffectParameter viewStartPosPara;

        EffectParameter viewSizePara;

        EffectParameter mapSizePara;

        EffectParameter screenViewStartPosPara;

        EffectParameter screenViewScalePara;

        EffectParameter gridSizePara;

        EffectParameter indexMapPara;

        EffectParameter tex1Para;

        EffectParameter tex2Para;

        EffectParameter tex3Para;



        #endregion

        #region Construction

        public SimpleTileGround ( SimpleTileData data, Rectangle screenViewRect, Vector2 mapSize )
        {
            gridWidth = data.width;
            gridHeight = data.height;

            this.screenViewRect = screenViewRect;

            this.mapSize = mapSize;

            texIndexs = new int[data.texIndexs.Length];
            data.texIndexs.CopyTo( texIndexs, 0 );

            InitialVertexBuffer();

            InitialIndexTex( data );

            InitialTexList( data );

            LoadEffect();
        }

        private void InitialVertexBuffer ()
        {
            vertexDeclar = new VertexDeclaration( BaseGame.Device,
                new VertexElement[]
                { 
                    new VertexElement( 0, 0, VertexElementFormat.Vector2, VertexElementMethod.Default, VertexElementUsage.Position, 0 )
                } );

            Vector2[] pos = new Vector2[(gridWidth + 1) * (gridHeight + 1)];

            for (int y = 0; y <= gridHeight; y++)
            {
                for (int x = 0; x <= gridWidth; x++)
                {
                    pos[x + y * (gridWidth + 1)] = new Vector2( (float)x / (float)gridWidth, (float)y / (float)gridHeight );
                }
            }

            vertexs = new VertexBuffer( BaseGame.Device,
                vertexDeclar.GetVertexStrideSize( 0 ) * (gridWidth + 1) * (gridHeight + 1),
                ResourceUsage.WriteOnly );

            vertexs.SetData<Vector2>( pos );

            uint[] index = new uint[gridWidth * gridHeight * 6];
            int currentIndex = 0;
            for (int y = 0; y < gridWidth; y++)
            {
                for (int x = 0; x < gridHeight; x++)
                {
                    index[currentIndex + 0] = (uint)(x + (gridWidth + 1) * y);
                    index[currentIndex + 1] = (uint)((x + 1) + (gridWidth + 1) * y);
                    index[currentIndex + 2] = (uint)((x + 1) + (gridWidth + 1) * (y + 1));
                    index[currentIndex + 3] = (uint)((x + 1) + (gridWidth + 1) * (y + 1));
                    index[currentIndex + 4] = (uint)(x + (gridWidth + 1) * (y + 1));
                    index[currentIndex + 5] = (uint)(x + (gridWidth + 1) * y);

                    currentIndex += 6;
                }
            }
            indexs = new IndexBuffer( BaseGame.Device, typeof( uint ),
                gridWidth * gridHeight * 6, ResourceUsage.WriteOnly );

            indexs.SetData<uint>( index );
        }

        private void InitialIndexTex ( SimpleTileData data )
        {
            texIndexTex = new Texture2D( BaseGame.Device, gridWidth, gridHeight, 1, ResourceUsage.None, SurfaceFormat.Alpha8 );
            byte[] index = new byte[gridWidth * gridHeight];
            for (int i = 0; i < texIndexs.Length; i++)
            {
                index[i] = (byte)(texIndexs[i] * 25);
            }

            texIndexTex.SetData<byte>( index );
        }

        private void InitialTexList ( SimpleTileData data )
        {
            TexList = new Texture2D[data.texPaths.Length];
            for (int i = 0; i < data.texPaths.Length; i++)
            {
                TexList[i] = Texture2D.FromFile( BaseGame.Device, data.texPaths[i] );
            }
        }

        private void LoadEffect ()
        {
            simpleTileEffect = BaseGame.Content.Load<Effect>( Path.Combine( Directories.ContentDirectory, "EffectFile\\SimpleTileGround" ) );

            viewStartPosPara = simpleTileEffect.Parameters["ViewStartPos"];
            viewSizePara = simpleTileEffect.Parameters["ViewSize"];
            mapSizePara = simpleTileEffect.Parameters["MapSize"];
            screenViewStartPosPara = simpleTileEffect.Parameters["ScrnStartPos"];
            screenViewScalePara = simpleTileEffect.Parameters["ScreenViewScale"];
            gridSizePara = simpleTileEffect.Parameters["GridSize"];
            indexMapPara = simpleTileEffect.Parameters["indexMap"];
            tex1Para = simpleTileEffect.Parameters["tex1"];
            tex2Para = simpleTileEffect.Parameters["tex2"];
            tex3Para = simpleTileEffect.Parameters["tex3"];

            mapSizePara.SetValue( mapSize );
            screenViewStartPosPara.SetValue( new float[] { (float)(screenViewRect.X) / (float)(BaseGame.ClientRect.Width),
                (float)(screenViewRect.Y) / (float)(BaseGame.ClientRect.Height)} );
            screenViewScalePara.SetValue( new float[]{ (float)(screenViewRect.Width) / (float)(BaseGame.ClientRect.Width ),
                (float)(screenViewRect.Height) / (float)(BaseGame.ClientRect.Height)} );
            gridSizePara.SetValue( new float[] { gridWidth, gridHeight } );
            indexMapPara.SetValue( texIndexTex );

            int i = 0;
            if (i < TexList.Length)
            {
                tex1Para.SetValue( TexList[i] );
                i++;
            }
            if (i < TexList.Length)
            {
                tex2Para.SetValue( TexList[i] );
                i++;
            }
            if (i < TexList.Length)
            {
                tex3Para.SetValue( TexList[i] );
                i++;
            }
        }

        #endregion

        #region IBackGround 成员

        // 通常并不需要动态的改变。
        //public void SetScreenViewRect ( Rectangle scrnViewRect )
        //{
        //    this.screenViewRect = scrnViewRect;
        //}



        public void Draw ( Rectanglef logicViewRect )
        {
            BaseGame.Device.RenderState.DepthBufferEnable = false;
            BaseGame.Device.RenderState.DepthBufferWriteEnable = false;
            BaseGame.Device.RenderState.AlphaBlendEnable = true;
            BaseGame.Device.RenderState.CullMode = CullMode.None;



            viewStartPosPara.SetValue( new float[] { logicViewRect.X, logicViewRect.Y } );
            viewSizePara.SetValue( new float[] { logicViewRect.Width, logicViewRect.Height } );

            simpleTileEffect.CommitChanges();

            BaseGame.Device.Clear( Color.TransparentBlack );

            simpleTileEffect.CurrentTechnique = simpleTileEffect.Techniques[0];
            simpleTileEffect.Begin();
            simpleTileEffect.CurrentTechnique.Passes[0].Begin();

            BaseGame.Device.VertexDeclaration = vertexDeclar;
            BaseGame.Device.Vertices[0].SetSource( vertexs, 0, vertexDeclar.GetVertexStrideSize( 0 ) );
            BaseGame.Device.Indices = indexs;
            BaseGame.Device.DrawIndexedPrimitives( PrimitiveType.TriangleList, 0, 0, (gridWidth + 1) * (gridHeight + 1), 0, gridWidth * gridHeight * 2 );

            simpleTileEffect.CurrentTechnique.Passes[0].End();
            simpleTileEffect.End();

            BaseGame.Device.RenderState.DepthBufferEnable = true;
            BaseGame.Device.RenderState.DepthBufferWriteEnable = true;
            BaseGame.Device.RenderState.CullMode = CullMode.CullCounterClockwiseFace;

        }

        #endregion
    }
}
