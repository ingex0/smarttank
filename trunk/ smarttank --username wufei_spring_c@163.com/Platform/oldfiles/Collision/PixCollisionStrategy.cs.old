using System;
using System.Collections.Generic;
using System.Text;
using GameBase.Graphics;
using GameBase.Interfaces;

namespace Platform.Logic.Collision
{
    class PixCollisionStrategy : ICollisionStrategy
    {
        #region ICollisionStrategy 成员

        public CollisionResult isColliding ( ICollidable objA, ICollidable objB )
        {
            return Sprite.IntersectPixels( objA.CollideSprite, objB.CollideSprite );
        }

        public void checkCollision ( Platform.Logic.Registers.Register<ICollidable> register )
        {
            ICollidable[] collides = register.ToArray();
            foreach (ICollidable col in collides)
            {
                col.CollideSprite.UpdateTransformBounding();
            }

            for (int i = 0; i < collides.Length - 1; i++)
            {
                for (int j = i + 1; j < collides.Length; j++)
                {
                    CollisionResult resultA = isColliding( collides[i], collides[j] );
                    if (resultA.isIntersected)
                    {

                        collides[i].HandleCollideWith( resultA, collides[j] );
                        CollisionResult resultB = isColliding( collides[j], collides[i] );
#if DEBUG
                        //if (!resultB.isIntersected)
                        //    throw new Exception();
#endif
                        // 以上异常依然会少量的出现。所以当B没有碰到A的时候将A的法向量翻转后传给B的Handle函数。
                        if (!resultB.isIntersected)
                        {
                            resultB.isIntersected = true;
                            resultB.InterPos = resultA.InterPos;
                            resultB.InterNormalVector = -resultA.InterNormalVector;
                        }
                        else
                        {
                            collides[j].HandleCollideWith( resultB, collides[i] );
                        }
                    }
                }
            }
        }

        #endregion
    }
}
