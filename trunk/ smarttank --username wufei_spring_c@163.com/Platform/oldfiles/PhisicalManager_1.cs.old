//#define DEBUG_Collision

using System;
using System.Collections.Generic;
using System.Text;
using Platform.PhisicalCollision;
using GameBase.Graphics;
using Platform.Common;
using GameBase.Helpers;



namespace Platform.PhisicalCollision
{
    class PhisicalManager_1 : IUpdater
    {

        #region IUpdater ≥…‘±

        const int MaxIterDepth = 1;

        public void Update ( float seconds )
        {
            iterDepth = 0;

            LinkedList<IPhisicalUpdater> phisicals = GameManager.ObjManager.PhisicalUpdaters;
            LinkedList<ICollider> colliders = GameManager.ObjManager.CollideUpdaters;
            Border border = GameManager.Border;

            foreach (IPhisicalUpdater phisical in phisicals)
            {
                phisical.CalNextStatus( seconds );
            }

            CollisionCheckResult[] colResults = CollisionChecker_1.DetectCollision( colliders, border );

            if (colResults.Length != 0)
            {
                HandleColResult( colResults, colliders, seconds );
            }

            foreach (IPhisicalUpdater phisical in phisicals)
            {
                phisical.Validated();
            }

        }

        int iterDepth = 0;
        private void HandleColResult ( CollisionCheckResult[] colResults, LinkedList<ICollider> colliders, float seconds )
        {
            iterDepth++;

            Border border = GameManager.Border;

#if DEBUG_Collision
            if (iterDepth > 1)
            {
                Log.Write( "" );
                Log.Write( "iterDepth = " + iterDepth );
            }
#endif


            if (iterDepth <= MaxIterDepth)
            {
                foreach (CollisionCheckResult result in colResults)
                {
                    result.ColA.HandleCollision( result.CollisionResult, result.ColB.ObjInfo );
                    if (result.ColA is IPhisicalUpdater)
                        (result.ColA as IPhisicalUpdater).CalNextStatus( seconds );

                    CollisionResult collisionResultB = new CollisionResult( result.CollisionResult.InterPos, -result.CollisionResult.NormalVector );
                    result.ColB.HandleCollision( collisionResultB, result.ColA.ObjInfo );
                    if (result.ColB is IPhisicalUpdater)
                        (result.ColB as IPhisicalUpdater).CalNextStatus( seconds );

#if DEBUG_Collision
                    if (iterDepth > 1)
                    {
                        Log.Write( "CollisionCheckResult : " + result.ColA.ObjInfo.Script + " " + result.ColB.ObjInfo.Script );
                        if (result.ColA is IPhisicalUpdater)
                        {
                            VelPosCollideUpdater colA = result.ColA as VelPosCollideUpdater;
                            Log.Write( "ColA : " + colA.Pos.ToString() + " " + colA.Vel.ToString() );
                        }
                        if (result.ColB is IPhisicalUpdater)
                        {
                            VelPosCollideUpdater colB = result.ColB as VelPosCollideUpdater;
                            Log.Write( "ColB : " + colB.Pos.ToString() + " " + colB.Vel.ToString() );
                        }
                    }
#endif

                }

                List<CollisionCheckResult> curColResults = new List<CollisionCheckResult>();

                foreach (CollisionCheckResult result in colResults)
                {
                    CollisionCheckResult[] tempResult = CollisionChecker_1.DetectCollision( result, colliders, border );
                    if (tempResult.Length != 0)
                    {
                        curColResults.AddRange( tempResult );
                    }
                }

                if (curColResults.Count == 0)
                    return;
                else
                    HandleColResult( curColResults.ToArray(), colliders, seconds );
            }
            else
            {
                HandleOverflowDepth = 0;
                HandleIterOverflow( colResults, colliders );
            }
        }

        int HandleOverflowDepth = 0;
        private void HandleIterOverflow ( CollisionCheckResult[] colResults, LinkedList<ICollider> colliders )
        {
            HandleOverflowDepth++;

#if DEBUG_Collision
            Log.Write( "HandleIterOverflow, iterDepth = " + HandleOverflowDepth.ToString() );
#endif

            Border border = GameManager.Border;

            if (HandleOverflowDepth > 100)
            {
                throw new Exception( "something wrong with HandleIterOverflow: IterDepth too big!" );
            }

            foreach (CollisionCheckResult result in colResults)
            {
                result.ColA.ClearNextStatus();
                result.ColB.ClearNextStatus();
            }

            List<CollisionCheckResult> curColResults = new List<CollisionCheckResult>();

            foreach (CollisionCheckResult result in colResults)
            {
                CollisionCheckResult[] tempResult = CollisionChecker_1.DetectCollision( result, colliders, border );
                if (tempResult.Length != 0)
                {
                    curColResults.AddRange( tempResult );
                }
            }

            if (curColResults.Count == 0)
                return;
            else
                HandleIterOverflow( curColResults.ToArray(), colliders );
        }

        #endregion
    }
}
