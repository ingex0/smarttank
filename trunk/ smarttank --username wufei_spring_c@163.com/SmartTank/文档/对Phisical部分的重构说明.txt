
由于以前讨论过的坦克在惯性物理系统下的控制问题。不得不设法让惯性物理系统和无惯性（不考虑物体加速度）物理系统同时存在。
在这个过程中又引发了以下的系列问题：

(1)由于PhisicalStatus类与IPhisical以及IPhisicalStrategy耦合，而PhisicalStatus类中的部分成员却又是与NewtonStrategy有现实的耦合性。
（让无惯性的物理系统对包含了质量、转动惯量的PhisicalStatus进行更新是不恰当的，这样会让所有被无惯性物理系统更新的物体类都包含原本不需要的成员。）
所以难以在IPhisicalStrategy接口中直接继承出新的无惯性物理系统。

(2)解决这个问题的办法只能是除去IPhisicalStrategy。将IPhisical改为INewtonPhisical。
而另为无惯性物理系统写相应的接口。也就是说策略模式已经不再存在了。

(3)而坦克也需要另外的状态更新系统，因为炮塔的转动以及坦克其他潜在的与时间有关的信息也可能需要更新。
同样，不同的物体需要有不同的更新方法，这些方法显然与物体的状态有关。

(4)从更抽象的逻辑上说，任何形式的更新方法，跟状态变量都存在一定的耦合性。而如第(2)条所述，策略模式实际上并不适用。
所以我建议用另一种组织模式来设计整个游戏的更新问题：

游戏中任何物体的更新都是每一帧执行一次，所以我们使用一个接口：IUpdater来定义Update的行为。

将一个更新内容的状态变量与更新方法放置在一起，成为一个Updater类。每一个类管理一种需要每帧更新的内容。

如：NewtonPhisicalUpdater（最好改名为InertiaPhisicalUpdater)将惯性物理系统的更新算法包括在类的成员中，同时包含惯性物理的更新算法。
需要按惯性物理方法更新自己的物体通过包含NewtonPhisicalUpdater成员来获得更新自己的物理状态的能力。

(5)另外考虑到一个一直以来悬而未决的问题：怎样安排碰撞和物理状态更新之间的关系。
如果在更理论的层面来阐述这个显露出的问题，便是怎样处理更新与外部环境作用和不同更新之间的相互作用的问题（如更新的次序问题）。




由于在编写的过程中发现了这些问题，也使我们对将要面对的问题有了一定的认识。所以我想，当前是一个对系统体系进行全面设计的时机。
我们要具体的指明程序中重要过程的执行顺序，计算方法。这是我们接下来需要讨论的。

