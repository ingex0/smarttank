


float2 ViewStartPos;

float2 ViewSize;

float2 MapSize;

float2 ScrnStartPos;

float2 ScreenViewScale;

float2 GridSize;

texture vertexIndexMap;

sampler vertexIndexMapSampler = sampler_state
{
	texture = <vertexIndexMap>;
	AddressU = CLAMP;
	AddressV = CLAMP;
	AddressW = CLAMP;
	MIPFILTER = NONE;
	MINFILTER = POINT;
    MAGFILTER = POINT;
};

texture gridIndexMap;

sampler gridIndexMapSampler = sampler_state
{
	texture = <gridIndexMap>;
	AddressU = CLAMP;
	AddressV = CLAMP;
	AddressW = CLAMP;
	MIPFILTER = NONE;
	MINFILTER = POINT;
    MAGFILTER = POINT;
};

texture tex1;

sampler texSampler1 = sampler_state
{
	texture = <tex1>;
	AddressU  = WRAP;
    AddressV  = WRAP;
    AddressW  = WRAP;
    MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture tex2;

sampler texSampler2 = sampler_state
{
	texture = <tex2>;
	AddressU = WRAP;
	AddressV = WRAP;
	AddressW = WRAP;
	MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture tex3;

sampler texSampler3 = sampler_state
{
	texture = <tex3>;
	AddressU = WRAP;
	AddressV = WRAP;
	AddressW = WRAP;
	MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture tex4;

sampler texSampler4= sampler_state
{
	texture = <tex4>;
	AddressU = WRAP;
	AddressV = WRAP;
	AddressW = WRAP;
	MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture tex5;

sampler texSampler5 = sampler_state
{
	texture = <tex5>;
	AddressU = WRAP;
	AddressV = WRAP;
	AddressW = WRAP;
	MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture tex6;

sampler texSampler6 = sampler_state
{
	texture = <tex6>;
	AddressU = WRAP;
	AddressV = WRAP;
	AddressW = WRAP;
	MIPFILTER = LINEAR;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};


float2 TranslateToRenderCoord( float2 logicPos )
{
	float2 result = ((logicPos * MapSize - ViewStartPos) / ViewSize) * ScreenViewScale + ScrnStartPos;
	result = 2 * result - 1;
	result.y = -result.y;
	return result;
}

float2 CalTexCoordFromWeight(float2 tex, int weight)
{
	
}

struct VertexInput
{
	float4 pos : POSITION;
};

struct VertexOutput
{
	float4 pos : POSITION;
	float2 tex : TEXCOORD0;	
};


VertexOutput VS_VergeTileGround(VertexInput In)
{
	VertexOutput Out;
	
	Out.pos = In.pos;
	Out.pos.xy = TranslateToRenderCoord(In.pos.xy);
	Out.tex = In.pos;
	
	return Out;
}

float4 PS_VergeTileGround(VertexOutput In):Color
{
	float2 vertexTexelSize = 1 / (GridSize + 1);
	float2 curPos = In.tex;
	
	int vertexIndex1 = tex2D(vertexIndexMapSampler,curPos + (1,1) * vertexTexelSize).a * 25.5f;
	int vertexIndex2 = tex2D(vertexIndexMapSampler,curPos + (0,1) * vertexTexelSize).a * 25.5f;
	int vertexIndex3 = tex2D(vertexIndexMapSampler,curPos + (1,0) * vertexTexelSize).a * 25.5f;
	int vertexIndex4 = tex2D(vertexIndexMapSampler,curPos + (0,0) * vertexTexelSize).a * 25.5f;
	
	int sum0 = 0;
	int sum1 = 0;
	int sum2 = 0;
	int sum3 = 0;
	int sum4 = 0;
	int sum5 = 0;
	
	
	if (vertexIndex1 == 0)
	{
		sum0 += 1;
	}
	else if (vertexIndex1 == 1)
	{
		sum1 += 1;
	}
	else if (vertexIndex1 == 2)
	{
		sum2 += 1;
	}
	else if (vertexIndex1 == 3)
	{
		sum3 += 1;
	}
	else if (vertexIndex1 == 4)
	{
		sum4 += 1;
	}
	else if (vertexIndex1 == 5)
	{
		sum5 += 1;
	}
	
	if (vertexIndex2 == 0)
	{
		sum0 += 2;
	}
	else if (vertexIndex2 == 1)
	{
		sum1 += 2;
	}
	else if (vertexIndex2 == 2)
	{
		sum2 += 2;
	}
	else if (vertexIndex2 == 3)
	{
		sum3 += 2;
	}
	else if (vertexIndex2 == 4)
	{
		sum4 += 2;
	}
	else if (vertexIndex2 == 5)
	{
		sum5 += 2;
	}
	
	if (vertexIndex3 == 0)
	{
		sum0 += 4;
	}
	else if (vertexIndex3 == 1)
	{
		sum1 += 4;
	}
	else if (vertexIndex3 == 2)
	{
		sum2 += 4;
	}
	else if (vertexIndex3 == 3)
	{
		sum3 += 4;
	}
	else if (vertexIndex3 == 4)
	{
		sum4 += 4;
	}
	else if (vertexIndex3 == 5)
	{
		sum5 += 4;
	}
	
	if (vertexIndex4 == 0)
	{
		sum0 += 8;
	}
	else if (vertexIndex4 == 1)
	{
		sum1 += 8;
	}
	else if (vertexIndex4 == 2)
	{
		sum2 += 8;
	}
	else if (vertexIndex4 == 3)
	{
		sum3 += 8;
	}
	else if (vertexIndex4 == 4)
	{
		sum4 += 8;
	}
	else if (vertexIndex4 == 5)
	{
		sum5 += 8;
	}

	

	return float4(1,1,1,1);
}

technique VergeTileGround
{
	pass VergeTileGround
	{
		VertexShader = compile vs_1_1 VS_VergeTileGround();
		PixelShader = compile ps_2_0 PS_VergeTileGround();
	}
}